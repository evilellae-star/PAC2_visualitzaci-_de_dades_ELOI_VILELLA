---
title: "PAC 2 ‚Äì Exploraci√≥ de t√®cniques de visualitzaci√≥ de dades"
author: "Eloi Vilella"
date: "`r format(Sys.Date(), '%Y-%m-%d')`"
output:
  html_document:
    theme: journal
    toc: true
    toc_depth: 3
    number_sections: true
    df_print: paged
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,      
  warning = FALSE,   
  message = FALSE,   
  results = 'hide',  
  fig.show = 'hold'  
)
```

<!-- Estil global per a totes les imatges del document -->

<style>
img.fullwidth {
  display: block;
  margin: 20px auto;
  width: 100%;
  max-width: 900px;
  height: auto;
  border-radius: 10px;
}
</style>

<div style="position: relative;">
  <img src="resources/logo.png" style="position: absolute; top: 0; right: 0; width: 150px;">
</div>

# Introducci√≥

En aquesta PAC 2 es demana sortir de la zona de confort explorant **tres t√®cniques de visualitzaci√≥** diferents.
L‚Äôobjectiu √©s entendre‚Äôn **l‚Äôorigen, el funcionament, els avantatges i limitacions**, i crear una **visualitzaci√≥ pr√≤pia** amb dades obertes per a cadascuna.

Les t√®cniques assignades s√≥n:

1. Dot Density Map\
2. Circular Dendrogram\
3. UpSet Plot

---

# 1. Dot Density Map

## Definici√≥ i origen

El **Dot Density Map** (o *dot distribution map*) √©s una t√®cnica de **cartografia tem√†tica** que representa la distribuci√≥ espacial d‚Äôun fenomen mitjan√ßant punts.
Cada punt representa una ocurr√®ncia (o un nombre determinat de casos) dins d‚Äôuna regi√≥ o pol√≠gon geogr√†fic.

Aquesta t√®cnica t√© una llarga tradici√≥ en la cartografia (m√©s de 150 anys d‚Äô√∫s). Avui s‚Äôutilitza √†mpliament en GIS i visualitzaci√≥ de dades modernes.

<div style="text-align: center;">
  <img src="resources/dot_density_map.png" class="fullwidth">
</div>

## Funcionament

* Cada punt simbolitza una quantitat determinada d‚Äôun fenomen (p. ex. 1 punt = 1 estaci√≥).
* Els punts es distribueixen dins d‚Äôuna √†rea, sovint de manera aleat√≤ria o ponderada (per exemple, proporcional a poblaci√≥).
* Zones amb m√©s punts indiquen major concentraci√≥; zones amb menys, baixa densitat.
* S'ha d'especificar clarament la **unitat del punt** (qu√® representa cada punt) per evitar interpretacions err√≤nies.

## Avantatges

* Visualitzaci√≥ **intuitiva** i f√†cil d'interpretar per maps de densitat.
* Permet comparar patrons espacials entre regions diferents.
* Pot mostrar m√∫ltiples categories utilitzant diferents colors o capes.

## Inconvenients

* Amb alt nombre de punts pot resultar **saturat** i perdre informaci√≥.
* La generaci√≥ aleat√≤ria de punts dins pol√≠gons pot induir variabilitat (problema de reproducibilitat si no es fixa la llavor).
* Subjecte al MAUP (modifiable areal unit problem): la mida i forma de les unitats administratives afecta la percepci√≥.

## Tipus de dades

* Dades geoespacials amb punts o geometries pol√≠gon (municipis, comarques, codis postals).
* Variables quantitatives agregades (poblaci√≥, incidents, punts d'inter√®s).

## Aplicacions habituals

* Densitat de poblaci√≥, habitatge o serveis.
* Distribuci√≥ d‚Äôinfraestructures: estacions de rec√†rrega, hospitals, escoles.
* Visualitzaci√≥ de distribuci√≥ d‚Äôesdeveniments puntuals (accidents, crims, etc.).

## Exemple d‚Äôaplicaci√≥ (codi i dades)

```{r}
library(sf)
library(ggplot2)
library(mapSpain)
library(dplyr)
library(readr)
library(stringr)
library(plotly)
library(tidyr)

# Exemple d'√∫s amb fitxer d'estacions (fitxer local)
df <- read_csv("data/Estacions_de_recaÃÄrrega_per_a_vehicle_eleÃÄctric_a_Catalunya_20251105.csv")
df_sf <- st_as_sf(df, wkt = "Georefer√®ncia", crs = 4326)
cat_map <- esp_get_ccaa("Catalunya")

ggplot() +
  geom_sf(data = cat_map, fill = "gray95", color = "gray70") +
  geom_sf(data = df_sf, color = "#0072B2", alpha = 0.6, size = 1) +
  labs(
    title = "Estacions de rec√†rrega per a vehicles el√®ctrics a Catalunya",
    subtitle = "1 punt = 1 estaci√≥ de rec√†rrega",
    caption = "Dades: Generalitat de Catalunya (Open Data)"
  ) +
  theme_minimal()
```

```{r}
df <- read_csv("data/Estacions_de_recaÃÄrrega_per_a_vehicle_eleÃÄctric_a_Catalunya_20251105.csv")

#Convertim la columna 'Georefer√®ncia' a geometria sf
df_sf <- st_as_sf(df, wkt = "Georefer√®ncia", crs = 4326)

#Extraiem coordenades
coords <- st_coordinates(df_sf)
df_sf <- df_sf %>%
  mutate(lon = coords[, 1], lat = coords[, 2])

#Neteja b√†sica
df_sf <- df_sf %>%
  filter(!is.na(`TIPUS VELOCITAT`), !is.na(POTENCIA))

#Separem els casos combinats
df_sf <- df_sf %>%
  mutate(`TIPUS VELOCITAT` = str_split(`TIPUS VELOCITAT`, " i ")) %>%
  tidyr::unnest(`TIPUS VELOCITAT`) %>%
  mutate(`TIPUS VELOCITAT` = str_trim(`TIPUS VELOCITAT`))

#Afegim la categoria Tots
vel_types <- sort(unique(df_sf$`TIPUS VELOCITAT`))
vel_types <- c("Tots", vel_types)

#Creem una tra√ßa per a cada tipus de velocitat
plots <- lapply(vel_types, function(v) {
  if (v == "Tots") {
    df_filt <- df_sf
  } else {
    df_filt <- df_sf %>% filter(`TIPUS VELOCITAT` == v)
  }

  list(
    type = "scattermapbox",
    mode = "markers",
    lon = df_filt$lon,
    lat = df_filt$lat,
    marker = list(
      size = 8,
      opacity = 0.8,
      color = df_filt$POTENCIA,
      colorscale = "Viridis",
      colorbar = list(title = "Pot√®ncia (kW)")
    ),
    text = paste0(
      "<b>Municipi:</b> ", df_filt$MUNICIPI,
      "<br><b>Pot√®ncia:</b> ", df_filt$POTENCIA, " kW",
      "<br><b>Tipus:</b> ", df_filt$`TIPUS VELOCITAT`
    ),
    hoverinfo = "text",
    name = v,
    visible = ifelse(v == "Tots", TRUE, FALSE)
  )
})

#Afegim les traces correctament
p <- plot_ly()
for (pl in plots) {
  p <- do.call(add_trace, c(list(p), pl))
}

#Botons per canviar tipus de velocitat
buttons <- lapply(seq_along(vel_types), function(i) {
  vis <- rep(FALSE, length(vel_types))
  vis[i] <- TRUE
  list(
    method = "update",
    args = list(list(visible = vis)),
    label = vel_types[i]
  )
})

p <- layout(
  p,
  mapbox = list(
    style = "open-street-map",
    zoom = 7.2,
    center = list(lon = 1.6, lat = 41.8)
  ),
  updatemenus = list(list(
    buttons = buttons,
    direction = "down",
    x = 0.05, y = 1.1,
    showactive = TRUE
  )),
  title = list(
    text = "üöó Estacions de rec√†rrega per tipus de velocitat a Catalunya",
    x = 0.5
  ),
  margin = list(l = 0, r = 0, b = 0, t = 50)
)

p

htmlwidgets::saveWidget(as_widget(p), "docs/dot_density_map_plotly.html", selfcontained = TRUE)

```

---

# 2. Circular Dendrogram

## Definici√≥ i origen

El **Circular Dendrogram** (o *Radial Dendrogram*) √©s una variaci√≥ del **dendrogram jer√†rquic** tradicional en qu√® l'arbre s'organitza de manera radial al voltant d'un eix central.
Els dendrograms deriven de t√®cniques d'**an√†lisi jer√†rquica** (hierarchical clustering), emprades hist√≤ricament en disciplines com la biologia i la taxonomia per mostrar relacions de parentesc o similitud.

El format circular es va popularitzar en bioinform√†tica i visualitzaci√≥ perqu√® **maximitza l'√∫s de l'espai** quan hi ha molts terminals (fulles), facilitant la visualitzaci√≥ de centenars o milers de fulles sense tallar l'arbre en p√†gines llargues.

<div style="text-align: center;">
  <img src="resources/circular_dendrogram.png" class="300">
</div>

## Funcionament

* Partim d'una matriu de dist√†ncies o d'una matriu de similitud entre elements.
* S'aplica un m√®tode d'agregaci√≥ jer√†rquica (p.ex. **UPGMA**, **Ward**, **single**, **complete**, o **neighbor-joining** en filogen√®tica).
* El resultat √©s un arbre (`hclust`, `phylo`) que s'ordena radialment: l'arrel al centre i les fulles al per√≠metre.
* Les longituds de branca poden representar dist√†ncies (si s'utilitzen m√®todes que conserven longituds) o b√© nom√©s la jerarquia (si `branch.length = "none"`).
* Es poden codificar atributs addicionals en color de branques, gruix, o etiquetes.

## Avantatges

* **Ocupa menys espai** vertical que un dendrogram lineal per a molts terminals.
* Millora la percepci√≥ de patrons globals i simetries en l'arbre.
* Ideal per integrar metadades (colores en branques, heatmaps externs).

## Inconvenients

* Les etiquetes poden ser **dif√≠cils de llegir** si hi ha moltes fulles ‚Äî sovint cal rotar o incloure etiquetes interactives.
* La dist√†ncia radial no sempre √©s directa d'interpretar; la comprensi√≥ de longituds radial/anglars pot confondre usuaris no t√®cnics.
* Per a comparacions quantitatives rigoroses entre dist√†ncies, els dendrograms lineals poden ser m√©s clars (sobretot si es necessiten escales legibles).

## Tipus de dades

* Dades jer√†rquiques o resultats d'agrupament: clustering de gens, esp√®cies, documents, usuaris, etc.
* Matrius de dist√†ncia (Euclidiana, cosinus, identitat, dist√†ncies evolutives).
* Formats R habituals: objectes `hclust`, `dendrogram`, `phylo`.

## Aplicacions habituals

* Filogen√®tica: arbres evolutius constru√Øts amb m√®todes com **neighbor-joining** o **maximum likelihood** (visualitzaci√≥).
* An√†lisi de clustering en ci√®ncia de dades: agrupament d'expressions g√®niques, patrons de consum, segmentacions.
* Mapes jer√†rquics d'organitzacions, taxonomies de categories, visualitzaci√≥ de l'estructura d'arbres de decisions.

## Exemple d‚Äôaplicaci√≥ (seq√º√®ncies proteiques)

En l‚Äôexemple seg√ºent es parteix d‚Äôun fitxer FASTA amb seq√º√®ncies proteiques, es realitza una alineaci√≥ m√∫ltiple, es calcula una matriu de dist√†ncies i es construeix un arbre amb l‚Äôalgorisme **Neighbor-Joining** (un m√®tode molt emprat per construcci√≥ r√†pida d'arbres filogen√®tics). El gr√†fic final s'exporta a PNG.

```{r}
library(DECIPHER)
library(Biostrings)
library(ape)
library(ggtree)
library(stringr)

# Fitxer fasta amb seq√º√®ncies prote√Øna: seqs.fasta
fasta_path <- "data/seqs.fasta"
seqs <- readAAStringSet(fasta_path)

# Extracci√≥ de noms d'organisme si els headers segueixen el patr√≥ "OS=... OX="
new_names <- str_extract(names(seqs), "(?<=OS=).*?(?= OX=)") %>% str_trim()
names(seqs) <- ifelse(is.na(new_names) | new_names == "", names(seqs), new_names)

# Alineament, conversi√≥ i c√†lcul de dist√†ncies
alignment <- AlignSeqs(seqs)                    # AlignSeqs de DECIPHER
alignment_mat <- as.matrix(alignment)
aligned_bin <- as.AAbin(alignment_mat)
dist_mat <- dist.aa(aligned_bin)                 # dist.aa (identitat / percentatge diferent)

# Construcci√≥ arbre amb Neighbor-Joining
tree <- nj(dist_mat)

# Visualitzaci√≥ circular amb ggtree
p <- ggtree(tree, layout = "circular", branch.length = "none") +
  xlim_tree(12) +
  geom_tiplab(aes(angle = angle), size = 3, hjust = 0, offset = 0.1) +
  theme_void() +
  ggtitle("Circular dendrogram ‚Äì Conserved RPL3 gene (UniProt sequences)") +
  theme(plot.title = element_text(hjust = 0.5, face = "bold"))

print(p)
ggsave("docs/circular_dendogram.png", plot = p, width = 8, height = 6, dpi = 300)
```

---

# 3. UpSet Plot

## Definici√≥ i origen

L‚Äô**UpSet Plot** √©s una t√®cnica per visualitzar **conjunts i les seves interseccions** de manera escalable i quantitativa. Va ser introdu√Øda per **Alexander Lex et al. (2014)** com a alternativa als diagrames de Venn i Euler, que esdevenen dif√≠cils de llegir a partir de 3 conjunts o m√©s. L‚Äôaplicaci√≥ √©s especialment valuosa quan es vol analitzar quantitats d'elements en interseccions espec√≠fiques i combinar aquesta informaci√≥ amb metadades.

<div style="text-align: center;">
  <img src="resources/Upset_Plot.png" class="fullwidth">
</div>

## Funcionament

* Es construeix una **matriu de pres√®ncia/abs√®ncia** on cada fila √©s un element i cada columna un conjunt.
* Les diferent combinacions de pres√®ncia (interseccions) es representen com files en una matriu de punts.
* Un gr√†fic de barres superior mostra la mida de cada intersecci√≥ (nombre d‚Äôelements que compleixen exactament aquella combinaci√≥).
* Un gr√†fic lateral mostra la mida de cada conjunt individual (cardinalitat).
* Es poden afegir m√®triques a les barres (p.ex. proporci√≥ d'un outcome com morts, mitjana d'una variable, etc.).

## Avantatges

* **Escalable**: funciona b√© amb molts conjunts (10+, si cal).
* Mostra clarament **quines interseccions s√≥n m√©s freq√ºents** i la seva mida.
* Permet afegir informaci√≥ quantitativa addicional (colors, valors laterals).
* √âs f√†cil ordenar les interseccions per mida, proporci√≥ o qualsevol m√®trica rellevant.

## Inconvenients

* Pot ser menys intu√Øtiu per a usuaris no acostumats a la matriu de punts.
* Amb masses interseccions diferents (p.ex. 2^n molt gran) cal filtrar i agrupar per interpretar les principals.
* Requereix preparar correctament la matriu de pres√®ncia/abs√®ncia (neteja i definici√≥ de conjunts).

## Tipus de dades

* Elements amb pertinen√ßa a conjunts (gens en experiments, clients per categories de compra, accidents amb tipus de vehicle, etc.).
* Dades bin√†ries (TRUE/FALSE) per cada conjunt, o convertibles a binari.

## Aplicacions habituals

* Gen√≤mica: conjunts de gens diferentsament expressats en condicions m√∫ltiples.
* An√†lisi de clients: combinacions de categories de compra.
* Epidemiologia/seguretat: combinacions d'exposicions o factors en incidents.

## Exemple d‚Äôaplicaci√≥ (accidents de tr√†nsit)

A continuaci√≥ hi ha el codi que processa un dataset d'accidents (fitxer local) per construir les interseccions entre tipus de vehicles implicats i obtenir mesures com el nombre d'accidents i la proporci√≥ de morts per cada combinaci√≥. El resultat es mostra com un UpSet-like plot (barra superior + matriu).

```{r}
library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(patchwork)

# Llegim dades (fitxer local)
df <- read_csv("data/Accidents_de_traÃÄnsit_amb_morts_o_ferits_greus_a_Catalunya_20251106.csv")
sets <- c("vianant", "bici", "ciclomotor", "moto", "lleuger", "pesant")

# Constru√Øm booleans per pertinen√ßa a cada conjunt
df_filt <- df %>%
  mutate(
    vianant = F_VIANANTS_IMPLICADES > 0,
    bici = F_BICICLETES_IMPLICADES > 0,
    ciclomotor = F_CICLOMOTORS_IMPLICADES > 0,
    moto = F_MOTOCICLETES_IMPLICADES > 0,
    lleuger = F_VEH_LLEUGERS_IMPLICADES > 0,
    pesant = F_VEH_PESANTS_IMPLICADES > 0,
    mortal = F_MORTS > 0
  )

# Matriu bin√†ria i etiquetes de combinacions
binmat <- as.matrix(df_filt %>% select(all_of(sets)) %>% mutate_all(~ as.integer(.)))
pattern <- apply(binmat, 1, paste0, collapse = "")
label <- apply(binmat, 1, function(r) {
  idx <- which(as.logical(r))
  if (length(idx) == 0) return("none")
  paste(sets[idx], collapse = ";")
})

# Resum per combinaci√≥: nombre d'accidents i morts
combos <- tibble(pattern = pattern, combo = label, mortal = df_filt$mortal) %>%
  group_by(pattern, combo) %>%
  summarise(n = n(), morts = sum(mortal, na.rm = TRUE), .groups = "drop") %>%
  mutate(prop_morts = if_else(n > 0, morts / n, 0)) %>%
  arrange(desc(n))

# Convertim cada combinaci√≥ a una "filera" de pres√®ncia per fer la matriu de punts
make_presence_df <- function(pat) {
  bits <- as.integer(strsplit(pat, "")[[1]])
  tibble(set = sets, present = as.logical(bits))
}

matrix_long <- combos %>%
  mutate(id = row_number()) %>%
  rowwise() %>%
  mutate(pres_df = list(make_presence_df(pattern))) %>%
  unnest_longer(pres_df) %>%
  unnest_wider(pres_df) %>%
  ungroup()

combo_order <- combos %>% filter(n > 0) %>% pull(combo)
matrix_long <- matrix_long %>%
  mutate(combo = factor(combo, levels = combo_order),
         set = factor(set, levels = rev(sets)))

# Gr√†fic superior: mida de les interseccions (color per proporci√≥ de morts)
p_top <- combos %>%
  filter(n > 0) %>%
  mutate(combo = factor(combo, levels = combo_order)) %>%
  ggplot(aes(x = combo, y = n, fill = prop_morts)) +
  geom_col() +
  scale_fill_viridis_c(labels = percent_format(accuracy = 1)) +
  labs(x = NULL, y = "Nombre d'accidents", fill = "Prop. morts",
       title = "Interseccions de tipus de vehicles implicats") +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        plot.title = element_text(hjust = 0.5, face = "bold"),
        legend.position = "right")

# Matriu de punts per a la matriu d'interseccions
p_matrix <- matrix_long %>%
  ggplot(aes(x = combo, y = set)) +
  geom_point(aes(alpha = present), size = 4) +
  scale_alpha_manual(values = c("FALSE" = 0, "TRUE" = 1), guide = "none") +
  labs(x = NULL, y = NULL) +
  theme_minimal(base_size = 11) +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_text(face = "bold"),
        panel.grid = element_blank())

final_plot <- p_top / p_matrix + plot_layout(heights = c(2, 1))

if (!dir.exists("docs")) dir.create("docs")
ggsave("docs/UpSet.png", plot = final_plot, width = 14, height = 6, dpi = 300)

final_plot
```
